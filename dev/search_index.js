var documenterSearchIndex = {"docs":
[{"location":"multithreading/#Multithreading","page":"Multithreading","title":"Multithreading","text":"","category":"section"},{"location":"multithreading/","page":"Multithreading","title":"Multithreading","text":"To start with, you need to make sure that your Julia session is started with multiple threads. See here for information on how to do this.","category":"page"},{"location":"multithreading/","page":"Multithreading","title":"Multithreading","text":"As of v0.3.0, you need to run the entire mice() function in parallel to get the full benefit of multithreading. It's advisable to set progressReports = false. For example, you could do something like this:","category":"page"},{"location":"multithreading/","page":"Multithreading","title":"Multithreading","text":"using CategoricalArrays, CSV, DataFrames, Mice, Random\n\nmyData = CSV.read(\"test/data/cirrhosis.csv\", DataFrame, missingstring = \"NA\");\n\nmyData.Stage = categorical(myData.Stage); # Making the Stage variable categorical\n\nmyPredictorMatrix = makePredictorMatrix(myData);\nmyPredictorMatrix[:, [\"ID\", \"N_Days\"]] .= 0;\n\nRandom.seed!(1234); # Set random seed for reproducibility\n\nimputedData = Vector{Mids}(undef, 10); # Initialise vector of Mids outputs\n\nThreads.@threads for i in 1:10 # Number of parallel runs\n    # Produces 5 x 10 = 50 imputed datasets in 10 separate Mids objects\n    imputedData[i] = mice(myData, m = 5, predictorMatrix = myPredictorMatrix, progressReports = false)\nend\n\nimputedData = bindImputations(imputedData); # Binds the separate Mids objects into a single output","category":"page"},{"location":"multithreading/","page":"Multithreading","title":"Multithreading","text":"<br> <div align=\"right\"> Funded by Wellcome &nbsp;&nbsp;&nbsp; <img src=\"../wellcome-logo-white.png\" style=\"vertical-align:middle\" alt=\"Wellcome logo\" width=\"50\" height=\"50\"> </div>","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"S. van Buuren and K. Groothuis-Oudshoorn, mice: Multivariate Imputation by Chained Equations in R. Journal of Statistical Software 45, 1–67 (2011), https://doi.org/10.18637/jss.v045.i03.\n\n\n\nS. van Buuren. Flexible Imputation of Missing Data. 2nd Edition (Chapman and Hall/CRC, New York, 2018).\n\n\n\nD. B. Rubin. Multiple imputation for nonresponse in surveys. 1st Edition (John Wiley & Sons, Ltd, New York, 1987). Accessed on Nov 8, 2023, https://onlinelibrary.wiley.com/doi/pdf/10.1002/9780470316696.\n\n\n\nE. R. Dickson, P. M. Grambsch, T. R. Fleming, L. D. Fisher and A. Langworthy. Prognosis in primary biliary cirrhosis: Model for decision making. Hepatology 10, 1–7 (1989), https://onlinelibrary.wiley.com/doi/pdf/10.1002/hep.1840100102.\n\n\n\n","category":"page"},{"location":"references/","page":"References","title":"References","text":"<br> <div align=\"right\"> Funded by Wellcome &nbsp;&nbsp;&nbsp; <img src=\"../wellcome-logo-white.png\" style=\"vertical-align:middle\" alt=\"Wellcome logo\" width=\"50\" height=\"50\"> </div>","category":"page"},{"location":"customising-imputation/#Customising-the-imputation-setup","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"","category":"section"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"You can customise various aspects of the imputation setup by passing keyword arguments to mice. These are described above. You can also use some of the functions below to define objects that you can customise to alter how mice handles the imputation.","category":"page"},{"location":"customising-imputation/#Locations-to-impute","page":"Customising the imputation setup","title":"Locations to impute","text":"","category":"section"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"You can customise which data points are imputed by manipulating the imputeWhere argument. By default, this will specify that all missing data are to be imputed (using the function findMissings()).","category":"page"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"findMissings","category":"page"},{"location":"customising-imputation/#Mice.findMissings","page":"Customising the imputation setup","title":"Mice.findMissings","text":"findMissings(data)\n\nReturns an AxisVector of boolean vectors describing the locations of missing data in each column of the provided data table.\n\n\n\n\n\n","category":"function"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"You can over-impute existing data by setting the locations of non-missing data to true in the relevant vector in imputeWhere. For example, to over-impute the value of col1 for the first row, you could do the following:","category":"page"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"using DataFrames, Mice, Random\n\nmyData = DataFrame(\n    :col1 => Vector{Union{Missing, Float64}}([1.0, missing, 3.0, missing, 5.0]),\n    :col2 => Vector{Union{Missing, Int64}}([1, 2, missing, 4, 5]),\n    :col3 => Vector{Union{Missing, String}}([missing, \"2\", missing, \"4\", missing])\n);\n\nmyImputeWhere = findMissings(myData)\n# 1-dimensional AxisArray{Vector{Bool},1,...} with axes:\n#     :row, [\"col1\", \"col2\", \"col3\"]\n# And data, a 3-element Vector{Vector{Bool}}:\n#  [0, 1, 0, 1, 0]\n#  [0, 0, 1, 0, 0]\n#  [1, 0, 1, 0, 1]\n\nmyImputeWhere[\"col1\"][1] = true;\nmyImputeWhere\n# 1-dimensional AxisArray{Vector{Bool},1,...} with axes:\n#     :row, [\"col1\", \"col2\", \"col3\"]\n# And data, a 3-element Vector{Vector{Bool}}:\n#  [1, 1, 0, 1, 0]\n#  [0, 0, 1, 0, 0]\n#  [1, 0, 1, 0, 1]\n\n# Not run\nmice(myData, imputeWhere = myImputeWhere)","category":"page"},{"location":"customising-imputation/#Visit-sequence","page":"Customising the imputation setup","title":"Visit sequence","text":"","category":"section"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"The visit sequence is the order in which the variables are imputed. By default, mice sorts the variables in order of missingness (lowest to highest) via the internal function makeMonotoneSequence. You can instead define your own visit sequence by creating a vector of variable names in your desired order and passing that to mice. For example:","category":"page"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"using DataFrames, Mice, Random\n\nmyData = DataFrame(\n    :col1 => Vector{Union{Missing, Float64}}([1.0, missing, 3.0, missing, 5.0]),\n    :col2 => Vector{Union{Missing, Int64}}([1, 2, missing, 4, 5]),\n    :col3 => Vector{Union{Missing, String}}([missing, \"2\", missing, \"4\", missing])\n);\n\nMice.makeMonotoneSequence(findMissings(myData))\n# 3-element Vector{String}:\n#  \"col2\"\n#  \"col1\"\n#  \"col3\"\n\nmyVisitSequence1 = names(myData)\n# 3-element Vector{String}:\n# \"col1\"\n# \"col2\"\n# \"col3\"\n\nRandom.seed!(1234); # Set random seed for reproducibility\n\n# Not run\nmice(myData, visitSequence = myVisitSequence1)\n\nmyVisitSequence2 = [\"col3\", \"col1\", \"col2\"]\n# 3-element Vector{String}:\n# \"col3\"\n# \"col1\"\n# \"col2\"\n\n# Not run\nmice(myData, visitSequence = myVisitSequence2)","category":"page"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"Assuming that the imputations converge normally, changing the visit sequence should not dramatically affect the output. However, it can be useful to change the visit sequence if you want to impute variables in a particular order for a specific reason. The sequence used by default in Mice.jl can make convergence faster in cases where the data follow a (near-)\"monotone\" missing data pattern [2].","category":"page"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"You can leave variables out of the visitSequence to cause mice() to not impute them.","category":"page"},{"location":"customising-imputation/#Predictor-matrix","page":"Customising the imputation setup","title":"Predictor matrix","text":"","category":"section"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"The predictor matrix defines which variables in the imputation model are used to predict which others. By default, every variable predicts every other variable, but there are a wide range of cases in which this is not desirable. For example, if your dataset includes an ID column, this is clearly useless for imputation and should be ignored.","category":"page"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"To create a default predictor matrix that you can edit, you can use the function makePredictorMatrix.","category":"page"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"makePredictorMatrix","category":"page"},{"location":"customising-imputation/#Mice.makePredictorMatrix","page":"Customising the imputation setup","title":"Mice.makePredictorMatrix","text":"makePredictorMatrix(data)\n\nReturns an AxisMatrix of integers defining the predictors for each variable in data. The variables to be predicted are on the rows, and the predictors are on the columns. The default is to use all variables as predictors for all other variables (i.e. all 1s except for the diagonal, which is 0).\n\n\n\n\n\n","category":"function"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"You can then edit the predictor matrix to remove any predictive relationships that you do not want to include in the imputation model. For example:","category":"page"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"using DataFrames, Mice, Random\n\nmyData = DataFrame(\n    :id => Vector{Int64}(1:5),\n    :col1 => Vector{Union{Missing, Float64}}([1.0, missing, 3.0, missing, 5.0]),\n    :col2 => Vector{Union{Missing, Int64}}([1, 2, missing, 4, 5]),\n    :col3 => Vector{Union{Missing, String}}([missing, \"2\", missing, \"4\", missing])\n);\n\nmyPredictorMatrix = makePredictorMatrix(myData)\n# 2-dimensional AxisArray{Int64,2,...} with axes:\n#     :row, [\"id\", \"col1\", \"col2\", \"col3\"]\n#     :col, [\"id\", \"col1\", \"col2\", \"col3\"]\n# And data, a 4x4 Matrix{Int64}:\n#  0  1  1  1\n#  1  0  1  1\n#  1  1  0  1\n#  1  1  1  0\n\n# To stop the ID column from predicting any other variable\nmyPredictorMatrix[:, \"id\"] .= 0;\nmyPredictorMatrix\n# 2-dimensional AxisArray{Int64,2,...} with axes:\n#     :row, [\"id\", \"col1\", \"col2\", \"col3\"]\n#     :col, [\"id\", \"col1\", \"col2\", \"col3\"]\n# And data, a 4x4 Matrix{Int64}:\n#  0  1  1  1\n#  0  0  1  1\n#  0  1  0  1\n#  0  1  1  0\n\n# To stop col1 from predicting col3\nmyPredictorMatrix[\"col3\", \"col1\"] = false;\nmyPredictorMatrix\n# 2-dimensional AxisArray{Int64,2,...} with axes:\n#     :row, [\"id\", \"col1\", \"col2\", \"col3\"]\n#     :col, [\"id\", \"col1\", \"col2\", \"col3\"]\n# And data, a 4x4 Matrix{Int64}:\n#  0  1  1  1\n#  0  0  1  1\n#  0  1  0  1\n#  0  0  1  0\n\nRandom.seed!(1234); # Set random seed for reproducibility\n\n# Not run\nmice(myData, predictorMatrix = myPredictorMatrix)","category":"page"},{"location":"customising-imputation/#Methods","page":"Customising the imputation setup","title":"Methods","text":"","category":"section"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"The imputation methods are the functions that are used to impute each variable. By default, mice uses predictive mean matching (\"pmm\") for all variables. Currently Mice.jl supports the following methods:","category":"page"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"Method Description Variable type\npmm Predictive mean matching Any\nrf Random forest Any (but see below)\nsample Random sample from observed values Any\nmean Mean of observed values Numeric (float)\nnorm Bayesian linear regression Numeric (float)","category":"page"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"<a name=\"rf-warning\">\n</a> ","category":"page"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"warning: Warning\nIf you use rf on a variable with integer values, the imputed values will be rounded to the nearest integer in the output. If you want to prevent this behaviour, you have two options:Convert the variable to a float before imputation, so it is treated as continuous or\nConvert the variable to a categorical/string array so it is treated as discrete.","category":"page"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"The mean and sample methods should not generally be used.","category":"page"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"To create a default methods vector, use the function makeMethods.","category":"page"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"makeMethods","category":"page"},{"location":"customising-imputation/#Mice.makeMethods","page":"Customising the imputation setup","title":"Mice.makeMethods","text":"makeMethods(data)\n\nReturns an AxisVector of strings defining the method by which each variable in data should be imputed in the mice() function. The default method is predictive mean matching (pmm).\n\n\n\n\n\n","category":"function"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"You can then customise the vector as needed. For example:","category":"page"},{"location":"customising-imputation/","page":"Customising the imputation setup","title":"Customising the imputation setup","text":"using DataFrames, Mice, Random\n\nmyData = DataFrame(\n    :id => Vector{Int64}(1:5),\n    :col1 => Vector{Union{Missing, Float64}}([1.0, missing, 3.0, missing, 5.0]),\n    :col2 => Vector{Union{Missing, Int64}}([1, 2, missing, 4, 5]),\n    :col3 => Vector{Union{Missing, String}}([missing, \"2\", missing, \"4\", missing])\n);\n\nmyMethods = makeMethods(myData)\n# 1-dimensional AxisArray{String,1,...} with axes:\n#     :row, [\"id\", \"col1\", \"col2\", \"col3\"]\n# And data, a 4-element Vector{String}:\n#  \"pmm\"\n#  \"pmm\"\n#  \"pmm\"\n#  \"pmm\"\n\n# To stop the ID column from being imputed (but you can also achieve this by leaving \"id\"\n# out of the visit sequence)\nmyMethods[\"id\"] = \"\";\nmyMethods\n# 1-dimensional AxisArray{String,1,...} with axes:\n#     :row, [\"id\", \"col1\", \"col2\", \"col3\"]\n# And data, a 4-element Vector{String}:\n#  \"\"\n#  \"pmm\"\n#  \"pmm\"\n#  \"pmm\"\n\n# To use Bayesian linear regression to impute col1\nmyMethods[\"col1\"] = \"norm\";\nmyMethods\n# 1-dimensional AxisArray{String,1,...} with axes:\n#     :row, [\"id\", \"col1\", \"col2\", \"col3\"]\n# And data, a 4-element Vector{String}:\n#  \"\"\n#  \"norm\"\n#  \"pmm\"\n#  \"pmm\"\n\nRandom.seed!(1234); # Set random seed for reproducibility\n\n# Not run\nmice(myData, methods = myMethods)","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"I have (very much not rigorously) benchmarked Mice.jl using the test dataset [4], and also performed an equivalent benchmark of the R package mice.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"15 iterations were completed to impute 12 variables (of which 4 binary categorical, 1 other categorical and 7 numeric) using a set of 18 predictors (those 12 variables plus 6 complete variables: 1 binary categorical, 2 other categorical and 3 numeric). Both used predictive mean matching for all variables that were to be imputed. In Mice.jl, gcSchedule was set to 0.3.","category":"page"},{"location":"benchmarks/#Benchmark-results","page":"Benchmarks","title":"Benchmark results","text":"","category":"section"},{"location":"benchmarks/#Windows","page":"Benchmarks","title":"Windows","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"System info: Single-threaded execution, Intel® Core™ i7-12700H 2.30GHz CPU, 32GB 4800MHz DDR5 RAM, running Windows 11 version 10.0.22621.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"R: version 4.3.2 running mice version 3.16.0. Julia: version 1.10.0 running Mice.jl version 0.3.2.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Number of imputations R (mice) (s) Mice.jl (s)\n1 1.79 4.86\n5 8.45 5.54\n10 16.59 6.55\n20 33.19 8.09\n50 85.79 12.17\n100 171.93 19.62","category":"page"},{"location":"benchmarks/#Linux","page":"Benchmarks","title":"Linux","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"System info: Single-threaded execution, Intel® Core™ i7-12700H 2.30GHz CPU, 32GB 4800MHz DDR5 RAM, running Ubuntu (WSL) version 22.04.3.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"R: version 4.3.2 running mice version 3.16.0. Julia: version 1.10.0 running Mice.jl version 0.3.2.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Number of imputations R (mice) (s) Mice.jl (s)\n1 1.24 4.93\n5 5.92 5.63\n10 11.74 6.56\n20 23.87 8.44\n50 63.83 12.54\n100 125.65 21.30","category":"page"},{"location":"benchmarks/#Why-is-Mice.jl-so-slow-for-small-jobs?","page":"Benchmarks","title":"Why is Mice.jl so slow for small jobs?","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Julia is a compiled language. This means that the first time a function is run, it is compiled into machine code, which takes time. Therefore, the first iteration of mice() will be (much) slower in Julia than in R, for example. However, subsequent iterations will be much faster, as all of the required functions are already compiled.","category":"page"},{"location":"benchmarks/#Why-is-the-first-iteration-so-much-slower-than-the-rest?","page":"Benchmarks","title":"Why is the first iteration so much slower than the rest?","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"See above.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<br> <div align=\"right\"> Funded by Wellcome &nbsp;&nbsp;&nbsp; <img src=\"../wellcome-logo-white.png\" style=\"vertical-align:middle\" alt=\"Wellcome logo\" width=\"50\" height=\"50\"> </div>","category":"page"},{"location":"mice/#Imputation-(mice)","page":"Imputation (mice)","title":"Imputation (mice)","text":"","category":"section"},{"location":"mice/","page":"Imputation (mice)","title":"Imputation (mice)","text":"The main function of the package is mice, which takes a Tables.jl-compatible table as its input. It returns a multiply imputed dataset (Mids) object with the imputed values.","category":"page"},{"location":"mice/","page":"Imputation (mice)","title":"Imputation (mice)","text":"Mids\nmice","category":"page"},{"location":"mice/#Mice.Mids","page":"Imputation (mice)","title":"Mice.Mids","text":"Mids\n\nA multiply imputed dataset object.\n\nThe data originally supplied are stored as data.\n\nThe imputed data are stored as imputations (one column per imputation).\n\nThe locations at which data have been imputed are stored as imputeWhere.\n\nThe number of imputations is stored as m.\n\nThe imputation method for each variable is stored as methods.\n\nThe predictor matrix is stored as predictorMatrix.\n\nThe order in which the variables are imputed is stored as visitSequence.\n\nThe number of iterations is stored as iter.\n\nThe mean of each variable across the imputations is stored as meanTraces.\n\nThe variance of each variable across the imputations is stored as varTraces.\n\n\n\n\n\n","category":"type"},{"location":"mice/#Mice.mice","page":"Imputation (mice)","title":"Mice.mice","text":"mice(\n    data;\n    m::Int = 5,\n    imputeWhere::AxisVector{Vector{Bool}} = findMissings(data),\n    visitSequence::Vector{String} = makeMonotoneSequence(imputeWhere),\n    methods::AxisVector{String} = makeMethods(data),\n    predictorMatrix::AxisMatrix{Int} = makePredictorMatrix(data),\n    iter::Int = 10,\n    progressReports::Bool = true,\n    gcSchedule::Float64 = 0.3,\n    kwargs...\n    )\n\nImputes missing values in a dataset using the MICE algorithm.  The output is a Mids object.\n\nThe data containing missing values (data) must be supplied as a Tables.jl table.\n\nThe number of imputations created is specified by m.\n\nimputeWhere is an AxisVector of boolean vectors specifying where data are to be imputed. The default is to impute all missing data.\n\nThe variables will be imputed in the order specified by visitSequence.  The default is sorted by proportion of missing data in ascending order;  the order can be customised using a vector of variable names in the desired order. Any column not to be imputed at all can be left out of the visit sequence.\n\nThe imputation method for each variable is specified by the AxisVector methods.  The default is to use predictive mean matching (pmm) for all variables. Any variable not to be imputed can be marked as such using an empty string (\"\").\n\nThe predictor matrix is specified by the AxisMatrix predictorMatrix.  The default is to use all other variables as predictors for each variable.  Any variable not predicting another variable can be marked as such in the matrix using a 0.\n\nThe number of iterations is specified by iter.\n\nIf progressReports is true, a progress indicator will be displayed in the console.\n\ngcSchedule dictates when the garbage collector will be (additionally) invoked. The  number provided is the fraction of your RAM remaining at which the GC will be called. For small datasets, you may get away with a value of 0.0 (never called), but for larger datasets, it may be worthwhile to call it more frequently. The default is 0.3, but for really large jobs you may want to increase this value.\n\n\n\n\n\nmice(\n    mids::Mids;\n    iter::Int = 10,\n    progressReports::Bool = true,\n    gcSchedule::Float64 = 0.3;\n    kwargs...\n    )\n\nAdds additional iterations to an existing Mids object.\n\nThe number of additional iterations is specified by iter.\n\nprogressReports and gcSchedule can also be specified: all other arguments will be ignored.\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/#Diagnostics","page":"Diagnostics","title":"Diagnostics","text":"","category":"section"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"After performing multiple imputation, you should inspect the trace plots of the imputed variables to verify convergence. Mice.jl includes a plotting function to do this.","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"plot","category":"page"},{"location":"diagnostics/#RecipesBase.plot","page":"Diagnostics","title":"RecipesBase.plot","text":"plot(\n    mids::Mids,\n    var::String\n    )\n\nPlots the mean and standard deviation of the imputed values for a given variable. Here var is given as a string (the name of the variable).\n\n\n\n\n\nplot(\n    mids::Mids,\n    var_no::Int\n    )\n\nPlots the mean and standard deviation of the imputed values for a given variable. Here var_no is given as an integer (the index of the variable in the visitSequence).\n\n\n\n\n\n","category":"function"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"You do need to load the package Plots.jl to see the plots:","category":"page"},{"location":"diagnostics/","page":"Diagnostics","title":"Diagnostics","text":"using Plots\n\n# Not run\nplot(myMids, 7)","category":"page"},{"location":"pooling/#Pooling-coefficients-(pool)","page":"Pooling coefficients (pool)","title":"Pooling coefficients (pool)","text":"","category":"section"},{"location":"pooling/","page":"Pooling coefficients (pool)","title":"Pooling coefficients (pool)","text":"Once you have a Mira object containing the results of repeated analyses, you can use the pool function to pool the results. The pool function returns the pooled results wrapped in a Mipo object.","category":"page"},{"location":"pooling/","page":"Pooling coefficients (pool)","title":"Pooling coefficients (pool)","text":"Mipo\npool","category":"page"},{"location":"pooling/#Mice.Mipo","page":"Pooling coefficients (pool)","title":"Mice.Mipo","text":"Mipo\n\nA type for storing the pooled results of multiply imputed repeated analyses (Mira).\n\n\n\n\n\n","category":"type"},{"location":"pooling/#Mice.pool","page":"Pooling coefficients (pool)","title":"Mice.pool","text":"pool(mira::Mira)\n\nPools the results of multiply imputed repeated analyses (Mira). The function will work on any Mira object containing model outputs which are receptive to the coef, stderror and nobs functions from StatsAPI.jl.\n\n\n\n\n\n","category":"function"},{"location":"pooling/","page":"Pooling coefficients (pool)","title":"Pooling coefficients (pool)","text":"The pool function should work on any Mira of model outputs that accept the StatsAPI functions coef, stderror and nobs. Otherwise, you will get an error and you will need to pool the results manually in accordance with Rubin's rules [3].","category":"page"},{"location":"pooling/","page":"Pooling coefficients (pool)","title":"Pooling coefficients (pool)","text":"For example:","category":"page"},{"location":"pooling/","page":"Pooling coefficients (pool)","title":"Pooling coefficients (pool)","text":"using CSV, DataFrames, GLM, Mice, Random\n\nmyData = CSV.read(\"test/data/cirrhosis.csv\", DataFrame, missingstring = \"NA\");\n\nmyData.Stage = categorical(myData.Stage); # Making the Stage variable categorical\n\nmyPredictorMatrix = makePredictorMatrix(myData);\nmyPredictorMatrix[:, [\"ID\", \"N_Days\"]] .= false;\n\nRandom.seed!(1234); # Set random seed for reproducibility\n\nimputedData = mice(myData, predictorMatrix = myPredictorMatrix);\n\nanalysesLMs = with(imputedData, data -> lm(@formula(N_Days ~ Drug + Age + Stage + Bilirubin), data));\n# returns Mira of linear model outputs from each imputed dataset\n\nresultsLMs = pool(analysesLMs);\n# returns Mipo of pooled linear model results","category":"page"},{"location":"pooling/","page":"Pooling coefficients (pool)","title":"Pooling coefficients (pool)","text":"<br> <div align=\"right\"> Funded by Wellcome &nbsp;&nbsp;&nbsp; <img src=\"../wellcome-logo-white.png\" style=\"vertical-align:middle\" alt=\"Wellcome logo\" width=\"50\" height=\"50\"> </div>","category":"page"},{"location":"analysis/#Analysis-(with)","page":"Analysis (with)","title":"Analysis (with)","text":"","category":"section"},{"location":"analysis/","page":"Analysis (with)","title":"Analysis (with)","text":"Once you have a Mids object containing imputed data, you can use it to perform repeated analyses.","category":"page"},{"location":"analysis/#Inspecting-imputed-data","page":"Analysis (with)","title":"Inspecting imputed data","text":"","category":"section"},{"location":"analysis/","page":"Analysis (with)","title":"Analysis (with)","text":"If you just want to inspect the outcome of the imputation process, you can use the complete/listComplete function to fill in the missing values in the original data frame.","category":"page"},{"location":"analysis/","page":"Analysis (with)","title":"Analysis (with)","text":"complete\nlistComplete","category":"page"},{"location":"analysis/#Mice.complete","page":"Analysis (with)","title":"Mice.complete","text":"complete(\n    mids::Mids,\n    imputation::Int\n    )\n\nProduces a data table with missings replaced with imputed values from a multiply imputed dataset (Mids) object.\n\nThe Mids object must be supplied first.\n\nThe imputation argument is an integer identifying which specific imputation is to be used to fill in the missing values.\n\n\n\n\n\n","category":"function"},{"location":"analysis/#Mice.listComplete","page":"Analysis (with)","title":"Mice.listComplete","text":"listComplete(\n    mids::Mids\n    )\n\nSummarises the outputs of all imputations in a multiply imputed dataset (Mids) as a list of completed datasets.\n\n\n\n\n\n","category":"function"},{"location":"analysis/#Data-analysis","page":"Analysis (with)","title":"Data analysis","text":"","category":"section"},{"location":"analysis/","page":"Analysis (with)","title":"Analysis (with)","text":"To perform a data analysis procedure on each imputed dataset in turn, use the with function. The with function returns the results of the analyses wrapped in a Mira object.","category":"page"},{"location":"analysis/","page":"Analysis (with)","title":"Analysis (with)","text":"Mira\nwith","category":"page"},{"location":"analysis/#Mice.Mira","page":"Analysis (with)","title":"Mice.Mira","text":"Mira\n\nA multiply imputed repeated analyses object.\n\nThe analyses are stored as a vector of analyses of individual imputations.\n\n\n\n\n\n","category":"type"},{"location":"analysis/#Mice.with","page":"Analysis (with)","title":"Mice.with","text":"with(\n    mids::Mids,\n    func::Function\n    )\n\nConducts repeated analyses of a multiply imputed dataset (Mids).\n\nThe function takes two arguments: firstly the Mids object itself, then a function (func). The function should take the form data -> analysisFunction(arguments, data, moreArguments...), where data represents the position of the data argument in the function.\n\nFor example: with(mids, data -> lm(@formula(y ~ x1 + x2), data))\n\n\n\n\n\n","category":"function"},{"location":"analysis/","page":"Analysis (with)","title":"Analysis (with)","text":"The with function requires the use of a closure, which then permits the function to run the specified analysis procedure on each imputed dataset in turn. For example:","category":"page"},{"location":"analysis/","page":"Analysis (with)","title":"Analysis (with)","text":"using CSV, DataFrames, GLM, Mice, Random, Statistics\n\nmyData = CSV.read(\"test/data/cirrhosis.csv\", DataFrame, missingstring = \"NA\");\n\nmyData.Stage = categorical(myData.Stage); # Making the Stage variable categorical\n\nmyPredictorMatrix = makePredictorMatrix(myData);\n\nmyPredictorMatrix[:, [\"ID\", \"N_Days\"]] .= false;\n\nRandom.seed!(1234); # Set random seed for reproducibility\n\nimputedData = mice(myData, predictorMatrix = myPredictorMatrix);\n\nanalysesMeans = with(imputedData, data -> mean(data.Cholesterol));\n# returns Mira of the mean of Bilirubin in each imputed dataset\n\nanalysesLMs = with(imputedData, data -> lm(@formula(N_Days ~ Drug + Age + Stage + Bilirubin), data));\n# returns Mira of linear model outputs from each imputed dataset","category":"page"},{"location":"analysis/","page":"Analysis (with)","title":"Analysis (with)","text":"<br> <div align=\"right\"> Funded by Wellcome &nbsp;&nbsp;&nbsp; <img src=\"../wellcome-logo-white.png\" style=\"vertical-align:middle\" alt=\"Wellcome logo\" width=\"50\" height=\"50\"> </div>","category":"page"},{"location":"whatsnext/#What's-next?","page":"What's next?","title":"What's next?","text":"","category":"section"},{"location":"whatsnext/","page":"What's next?","title":"What's next?","text":"Aspirational features for future releases include:","category":"page"},{"location":"whatsnext/","page":"What's next?","title":"What's next?","text":"Other imputation methods;\n2-level imputation and\nCUDA support.","category":"page"},{"location":"whatsnext/","page":"What's next?","title":"What's next?","text":"If there are any features you particularly want to see, please raise an issue on the issues page.","category":"page"},{"location":"whatsnext/","page":"What's next?","title":"What's next?","text":"<br> <div align=\"right\"> Funded by Wellcome &nbsp;&nbsp;&nbsp; <img src=\"../wellcome-logo-white.png\" style=\"vertical-align:middle\" alt=\"Wellcome logo\" width=\"50\" height=\"50\"> </div>","category":"page"},{"location":"binding-imputations/#Binding-imputations-together","page":"Binding imputations together","title":"Binding imputations together","text":"","category":"section"},{"location":"binding-imputations/","page":"Binding imputations together","title":"Binding imputations together","text":"If you have a number of Mids objects that were produced in the same way (e.g. through multithreading), you can bind them together into a single Mids object using the function bindImputations. Note that the log of events might not make sense in the resulting object: it is better to inspect the logs of the individual objects before binding them together.","category":"page"},{"location":"binding-imputations/","page":"Binding imputations together","title":"Binding imputations together","text":"bindImputations","category":"page"},{"location":"binding-imputations/#Mice.bindImputations","page":"Binding imputations together","title":"Mice.bindImputations","text":"bindImputations(\n    mids1::Mids,\n    mids2::Mids\n    )\n\nCombines two Mids objects into one. The two objects must have been created from the same dataset, with the same imputation methods, predictor matrix, visit sequence and number of iterations. The numbers of imputations can be different.\n\n\n\n\n\nbindImputations(\n    midsVector::Vector{Mids}\n    )\n\nCombines a vector of Mids objects into one Mids object. They must all have been created from the same dataset with the same imputation methods, predictor matrix, visit sequence and number of iterations. The number of imputations can be different.\n\n\n\n\n\nbindImputations(\n    mids...\n    )\n\nCombines any number of Mids objects into one Mids object. They must all have been created from the same dataset with the same imputation methods, predictor matrix, visit sequence and number of iterations. The number of imputations can be different.\n\n\n\n\n\n","category":"function"},{"location":"binding-imputations/","page":"Binding imputations together","title":"Binding imputations together","text":"<br> <div align=\"right\"> Funded by Wellcome &nbsp;&nbsp;&nbsp; <img src=\"../wellcome-logo-white.png\" style=\"vertical-align:middle\" alt=\"Wellcome logo\" width=\"50\" height=\"50\"> </div>","category":"page"},{"location":"rcall/#Integration-with-R","page":"Integration with R","title":"Integration with R","text":"","category":"section"},{"location":"rcall/","page":"Integration with R","title":"Integration with R","text":"If you don't want to use Julia for your data analysis, but you'd like to try out Mice.jl, good news - you can call R functions from Julia! The Julia package RCall.jl allows you to do this.","category":"page"},{"location":"rcall/","page":"Integration with R","title":"Integration with R","text":"You can start in Julia, perform your data wrangling in R, use Mice.jl and then send your Mids object back to R and continue analysing it there. For example:","category":"page"},{"location":"rcall/","page":"Integration with R","title":"Integration with R","text":"julia> using Mice, Random, RCall\n\n# You can switch from Julia to R by entering $\n\nR> data <- read.csv(\"test/data/cirrhosis.csv\")\n\nR> data$Stage <- as.factor(data$Stage)\n\n# Return to Julia by pressing backspace\n\njulia> @rget data\n\njulia> predictorMatrix = makePredictorMatrix(data);\n    \njulia> predictorMatrix[:, [\"ID\", \"N_Days\"]] .= false;\n\njulia> Random.seed!(1234); # Set random seed for reproducibility\n\njulia> imputedData = mice(data, predictorMatrix = predictorMatrix);\n\njulia> @rput imputedData\n\nR> library(mice)\n\nR> analyses <- with(imputedData, lm(N_Days ~ Drug + Age + Stage + Bilirubin))\n\nR> results <- summary(pool(analyses))","category":"page"},{"location":"rcall/","page":"Integration with R","title":"Integration with R","text":"<br> <div align=\"right\"> Funded by Wellcome &nbsp;&nbsp;&nbsp; <img src=\"../wellcome-logo-white.png\" style=\"vertical-align:middle\" alt=\"Wellcome logo\" width=\"50\" height=\"50\"> </div>","category":"page"},{"location":"wrangling/#Data-wrangling-in-Julia","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"","category":"section"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"The procedures used for data wrangling in Julia are often very similar to those used in R. However, there are some fundamental differences between the languages that it is important to be aware of.","category":"page"},{"location":"wrangling/#Data-types","page":"Data wrangling in Julia","title":"Data types","text":"","category":"section"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"Julia has a number of different data types. These include integers, floats, strings (known in R as \"characters\"), booleans and missing values.","category":"page"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"In a DataFrame or other table, each column will have at least one type assigned to it. For example:","category":"page"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"using DataFrames\n\nmyData = DataFrame(\n    :col1 => [1.0, 2.0, 3.0, 4.0],\n    :col2 => [1, 2, 3, 4],\n    :col3 => [\"1\", \"2\", \"3\", \"4\"],\n    :col4 => [1.0, 2.0, missing, 4.0],\n    :col5 => [1, 2.0, \"3\", missing]\n);\n\nmyData.col1\n# 4-element Vector{Float64}:\n#  1.0\n#  2.0\n#  3.0\n#  4.0\n\nmyData.col2\n# 4-element Vector{Int64}:\n#  1\n#  2\n#  3\n#  4\n\nmyData.col3\n# 4-element Vector{String}:\n#  \"1\"\n#  \"2\"\n#  \"3\"\n#  \"4\"\n\nmyData.col4\n# 4-element Vector{Union{Missing, Float64}}:\n#  1.0\n#  2.0\n#   missing\n#  4.0\n\nmyData.col5\n# 4-element Vector{Any}:\n#  1\n#  2.0\n#   \"3\"\n#   missing","category":"page"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"The first three columns have a single type assigned to them. The fourth column has a Union type, which means that it can be either a Float64 or missing. The fifth column has an Any type, which means that it can be any type.","category":"page"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"If you try to replace a value in a column with a value of the wrong type, one of two things will happen:","category":"page"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"myData[3, :col3] = 5\n# ERROR: MethodError: Cannot `convert` an object of type Int64 to an object of type String\n# ...\n\nmyData[3, :col1] = 5;\nmyData.col1\n# 4-element Vector{Float64}:\n#  1.0\n#  2.0\n#  5.0\n#  4.0","category":"page"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"As you can see, the first example throws an error, because you cannot convert an integer to a string. The second example works, because you can convert an integer to a float.","category":"page"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"You can amend a column to allow missing values using the allowmissing function:","category":"page"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"myData.col1 = allowmissing(myData.col1)\n# 4-element Vector{Union{Missing, Float64}}:\n#  1.0\n#  2.0\n#  5.0\n#  4.0","category":"page"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"or you can achieve this in place using the allowmissing! function:","category":"page"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"allowmissing!(myData, 3);\nmyData.col3\n# 4-element Vector{Union{Missing, String}}:\n#  \"1\"\n#  \"2\"\n#  \"3\"\n#  \"4\"","category":"page"},{"location":"wrangling/#Preparing-your-data-for-mice","page":"Data wrangling in Julia","title":"Preparing your data for mice","text":"","category":"section"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"The mice function in Mice.jl requires a Tables.jl-compatible table as its first argument. Columns which contain values of the missing type will be imputed (unless you specify otherwise: more on this later).","category":"page"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"(Continuous) numeric variables don't require any special treatment. However, categorical variables are handled differently and may require some additional preparation.","category":"page"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"Mice.jl is compatible with CategoricalArrays.jl, which allows you to specify that a column is categorical. For example:","category":"page"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"using CategoricalArrays, DataFrames\n\nmyData = DataFrame(\n    :col1 => [1, 2, 2, 3],\n    :col2 => categorical([1, 2, 2, 3])\n);\n\nmyData.col1\n# 4-element Vector{Int64}:\n#  1\n#  2\n#  2\n#  3\n\nmyData.col2\n# 4-element CategoricalArray{Int64,1,UInt32}:\n#  1\n#  2\n#  2\n#  3","category":"page"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"As you can see, the col2 column is now a CategoricalArray. This is a special type of array that allows you to specify that a column is categorical. This is important, because mice will treat categorical variables differently to continuous variables.","category":"page"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"If you have a column that contains strings (with or without missings, but with no other types), Mice.jl will handle it as a categorical variable automatically.","category":"page"},{"location":"wrangling/","page":"Data wrangling in Julia","title":"Data wrangling in Julia","text":"<br> <div align=\"right\"> Funded by Wellcome &nbsp;&nbsp;&nbsp; <img src=\"../wellcome-logo-white.png\" style=\"vertical-align:middle\" alt=\"Wellcome logo\" width=\"50\" height=\"50\"> </div>","category":"page"},{"location":"gettingstarted/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"gettingstarted/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"To install the latest stable version:","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"] add Mice","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"or","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"using Pkg\nPkg.add(\"Mice\")","category":"page"},{"location":"gettingstarted/#Usage","page":"Getting started","title":"Usage","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"To load the package, use the command:","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"using Mice","category":"page"},{"location":"gettingstarted/","page":"Getting started","title":"Getting started","text":"<br> <div align=\"right\"> Funded by Wellcome &nbsp;&nbsp;&nbsp; <img src=\"../wellcome-logo-white.png\" style=\"vertical-align:middle\" alt=\"Wellcome logo\" width=\"50\" height=\"50\"> </div>","category":"page"},{"location":"acknowledgements/#Acknowledgements","page":"Acknowledgements","title":"Acknowledgements","text":"","category":"section"},{"location":"acknowledgements/","page":"Acknowledgements","title":"Acknowledgements","text":"This package is based heavily on the existing R package {mice} by Stef van Buuren, Karin Groothuis-Oudshoorn and collaborators [1].","category":"page"},{"location":"acknowledgements/","page":"Acknowledgements","title":"Acknowledgements","text":"The development of this package was supported by the Wellcome Trust [218497/Z/19/Z].","category":"page"},{"location":"acknowledgements/","page":"Acknowledgements","title":"Acknowledgements","text":"<br> <div align=\"right\"> Funded by Wellcome &nbsp;&nbsp;&nbsp; <img src=\"../wellcome-logo-white.png\" style=\"vertical-align:middle\" alt=\"Wellcome logo\" width=\"50\" height=\"50\"> </div>","category":"page"},{"location":"issues/#Issues","page":"Issues","title":"Issues","text":"","category":"section"},{"location":"issues/","page":"Issues","title":"Issues","text":"This package is an early work in progress, and issues should be expected. When you find issues, please report them on the issues page.","category":"page"},{"location":"issues/","page":"Issues","title":"Issues","text":"<br> <div align=\"right\"> Funded by Wellcome &nbsp;&nbsp;&nbsp; <img src=\"../wellcome-logo-white.png\" style=\"vertical-align:middle\" alt=\"Wellcome logo\" width=\"50\" height=\"50\"> </div>","category":"page"},{"location":"#What-is-Mice.jl?","page":"What is Mice.jl?","title":"What is Mice.jl?","text":"","category":"section"},{"location":"","page":"What is Mice.jl?","title":"What is Mice.jl?","text":"Mice.jl is the Julia equivalent of the R package mice by Stef van Buuren, Karin Groothuis-Oudshoorn and collaborators [1]. It allows you to impute missing values in a dataset using multiple imputation by chained equations (MICE).","category":"page"},{"location":"","page":"What is Mice.jl?","title":"What is Mice.jl?","text":"Currently, only predictive mean matching (PMM) and Bayesian linear regression are supported as methods. Mice.jl also currently does not support hybrid imputation models.","category":"page"},{"location":"","page":"What is Mice.jl?","title":"What is Mice.jl?","text":"If you want to learn more about multiple imputation, this is not the guide for you. Instead, I recommend consulting \"Flexible Imputation of Missing Data\" by Stef van Buuren (ed.) [2].","category":"page"},{"location":"","page":"What is Mice.jl?","title":"What is Mice.jl?","text":"<br> <div align=\"right\"> Funded by Wellcome &nbsp;&nbsp;&nbsp; <img src=\"wellcome-logo-white.png\" style=\"vertical-align:middle\" alt=\"Wellcome logo\" width=\"50\" height=\"50\"> </div>","category":"page"}]
}
